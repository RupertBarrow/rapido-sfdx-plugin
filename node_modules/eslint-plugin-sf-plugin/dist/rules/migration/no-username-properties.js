"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noUsernameProperties = void 0;
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const utils_1 = require("@typescript-eslint/utils");
const commands_1 = require("../../shared/commands");
const flags_1 = require("../../shared/flags");
const propertyMap = new Map([
    [
        'requiresUsername',
        {
            flag: 'requiredOrgFlagWithDeprecations',
            flagName: 'target-org',
            message: 'requires',
        },
    ],
    ['supportsUsername', { flag: 'optionalOrgFlagWithDeprecations', flagName: 'target-org', message: 'supports' }],
    [
        'requiresDevhubUsername',
        {
            flag: 'requiredHubFlagWithDeprecations',
            flagName: 'target-dev-hub',
            message: 'requiresHub',
        },
    ],
]);
exports.noUsernameProperties = utils_1.ESLintUtils.RuleCreator.withoutDocs({
    meta: {
        docs: {
            description: 'Convert requiresUsername and supportusername to username flags',
            recommended: 'error',
        },
        messages: {
            requires: 'Class property requiresUsername is not available on SfCommand and should be removed.  Import `requiredOrgFlagWithDeprecations` from `@salesforce/sf-plugins-core` and add it to the flags object.',
            requiresHub: 'Class property requiresDevhubUsername is not available on SfCommand and should be removed.  Import `requiredHubFlagWithDeprecations` from `@salesforce/sf-plugins-core` and add it to the flags object.',
            supports: 'Class property supportUsername is not available on SfCommand and should be removed.  Import `optionalOrgFlagWithDeprecations` from `@salesforce/sf-plugins-core` and add it to the flags object.',
        },
        type: 'problem',
        schema: [],
        fixable: 'code',
    },
    defaultOptions: [],
    create(context) {
        return (0, commands_1.isInCommandDirectory)(context)
            ? {
                PropertyDefinition(node) {
                    var _a, _b;
                    if ((0, commands_1.ancestorsContainsSfCommand)(context.getAncestors())) {
                        if (node.key.type === utils_1.AST_NODE_TYPES.Identifier && propertyMap.has(node.key.name)) {
                            const mappedMetadata = propertyMap.get(node.key.name);
                            if (!mappedMetadata) {
                                return;
                            }
                            // ensure the import exists
                            const ancestors = context.getAncestors();
                            const source = context.getSourceCode();
                            const importDeclaration = (0, commands_1.getSfImportFromProgram)(ancestors[0]);
                            if (importDeclaration && !source.getText(importDeclaration).includes(mappedMetadata.flag)) {
                                const fixedImport = source
                                    .getText(importDeclaration)
                                    .replace(/{(.*)}/g, `{$1, ${mappedMetadata.flag}}`);
                                context.report({
                                    node: importDeclaration,
                                    messageId: mappedMetadata.message,
                                    fix: (fixer) => fixer.replaceText(importDeclaration, fixedImport),
                                });
                            }
                            // add the flag if not already present
                            const outerClass = (0, commands_1.getSfCommand)(ancestors);
                            if (!outerClass) {
                                return;
                            }
                            const flagsProperty = (0, flags_1.getFlagsStaticPropertyFromCommandClass)(outerClass);
                            if (flagsProperty &&
                                !source.getText(flagsProperty).includes(mappedMetadata.flag) &&
                                typeof ((_a = flagsProperty.value) === null || _a === void 0 ? void 0 : _a.range[0]) == 'number') {
                                const addedFlag = `'${mappedMetadata.flagName}': ${mappedMetadata.flag},`;
                                const removeRange = [((_b = flagsProperty.value) === null || _b === void 0 ? void 0 : _b.range[0]) + 1, flagsProperty.value.range[0] + 1];
                                context.report({
                                    node,
                                    messageId: mappedMetadata.message,
                                    fix: (fixer) => fixer.insertTextAfterRange(removeRange, addedFlag),
                                });
                            }
                            if (source.getText(importDeclaration).includes(mappedMetadata.flag) &&
                                source.getText(flagsProperty).includes(mappedMetadata.flag)) {
                                // remove the property only after the other two fixes have been applied
                                context.report({
                                    node,
                                    messageId: mappedMetadata.message,
                                    data: {
                                        property: node.key.name,
                                    },
                                    fix: (fixer) => fixer.remove(node),
                                });
                            }
                        }
                    }
                },
            }
            : {};
    },
});
