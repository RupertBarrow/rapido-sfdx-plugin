"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommandNameParts = exports.getSfImportFromProgram = exports.getRunMethod = exports.isRunMethod = exports.isInCommandDirectory = exports.getClassPropertyIdentifierName = exports.extendsSfCommand = exports.getSfCommand = exports.ancestorsContainsSfCommand = void 0;
const path_1 = require("path");
const utils_1 = require("@typescript-eslint/utils");
const ancestorsContainsSfCommand = (ancestors) => ancestors.some((a) => utils_1.ASTUtils.isNodeOfType(utils_1.AST_NODE_TYPES.ClassDeclaration)(a) && (0, exports.extendsSfCommand)(a));
exports.ancestorsContainsSfCommand = ancestorsContainsSfCommand;
const getSfCommand = (ancestors) => ancestors.filter(utils_1.ASTUtils.isNodeOfType(utils_1.AST_NODE_TYPES.ClassDeclaration)).find((a) => a && (0, exports.extendsSfCommand)(a));
exports.getSfCommand = getSfCommand;
const extendsSfCommand = (node) => { var _a; return ((_a = node.superClass) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Identifier && node.superClass.name === 'SfCommand'; };
exports.extendsSfCommand = extendsSfCommand;
const getClassPropertyIdentifierName = (node) => node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && node.key.type === utils_1.AST_NODE_TYPES.Identifier
    ? node.key.name
    : undefined;
exports.getClassPropertyIdentifierName = getClassPropertyIdentifierName;
// we don't care what the types are, really any context will do
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isInCommandDirectory = (context) => { var _a, _b; return (_b = (_a = context.getPhysicalFilename) === null || _a === void 0 ? void 0 : _a.call(context).includes(`src${path_1.sep}commands${path_1.sep}`)) !== null && _b !== void 0 ? _b : false; }; // not an sfCommand
exports.isInCommandDirectory = isInCommandDirectory;
const isRunMethod = (node) => node.type === utils_1.AST_NODE_TYPES.MethodDefinition &&
    node.kind === 'method' &&
    node.computed === false &&
    node.accessibility === 'public' &&
    node.static === false &&
    node.override === false &&
    node.key.type === utils_1.AST_NODE_TYPES.Identifier &&
    node.key.name === 'run';
exports.isRunMethod = isRunMethod;
const getRunMethod = (node) => node.body.body.find((b) => (0, exports.isRunMethod)(b));
exports.getRunMethod = getRunMethod;
const getSfImportFromProgram = (node) => {
    if (node.type === utils_1.AST_NODE_TYPES.Program) {
        return node.body
            .filter(utils_1.ASTUtils.isNodeOfType(utils_1.AST_NODE_TYPES.ImportDeclaration))
            .find((item) => item.source.type === utils_1.AST_NODE_TYPES.Literal && item.source.value === '@salesforce/sf-plugins-core');
    }
};
exports.getSfImportFromProgram = getSfImportFromProgram;
/** pass a filename, and get back an array of the parts that occur after `commands`
 * in other words, the command's canonical name
 */
const getCommandNameParts = (filename) => {
    const parts = filename.replace((0, path_1.parse)(filename).ext, '').split(path_1.sep);
    return parts.slice(parts.indexOf('commands') + 1);
};
exports.getCommandNameParts = getCommandNameParts;
